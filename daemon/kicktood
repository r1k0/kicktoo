#!/usr/bin/env perl

use strict;
use warnings;

use HTTP::Daemon;
use HTTP::Status;

my %conf = (
    bind_address => "0.0.0.0",
    port         => 1337,
    debug        => 1
);

my @profiles = ();

# ./kicktood --conf $config_path
my $config_path = join(' ', @ARGV[1..(@ARGV-1)]);

# read kicktood.conf
open CONF, $config_path || die "ERROR: run ./kicktood --conf <path to kicktood.conf>";
my $conf = join "", <CONF>;
close CONF;
eval $conf; die "Can not eval $config_path" if $@;

sub debug {
    my $msg = shift;

    if($conf{debug}) {
        print "DEBUG: " . $msg . "\n";
    }
}

sub create_daemon {
    return HTTP::Daemon->new(
        LocalAddr => $conf{bind_address},
        LocalPort => $conf{port},
        Reuse => 1
    );
}

sub parse_request_url {
    my $url = shift;

    $url =~ /^([^?]+)(?:\?(.*))?$/;
    my $path = $1;
    my $args = {};
    if(defined $2) {
        foreach my $pair (split /&/, $2) {
            my @parts = split /=/, $pair;
            $parts[1] =~ s/\+/ /g;
            $args->{$parts[0]} = $parts[1];
        }
    }
    return ($path, $args);
}

sub send_response {
    my ($conn, $response) = @_;

    debug("Sending response: " . $response);
    $conn->send_basic_header(200);
    $conn->send_crlf;
    print $conn $response;
}

sub get_profile_path {
    my $mac = shift;

    my $profile_path;
    my @macparts = split /:/, $mac;

#    open TMP, "< /tmp/kicktood.profiles";
#    my @profiles;
#    while(<TMP>) {
#        chomp;
#        my @parts = split /\s+/;
#        push @profiles, \@parts;
#    }
#    close TMP;

    foreach my $profile (@profiles) {
        my @profile_macparts = split /:/, $profile->[0];
        my $match = 1;

        for(0..5) {
            last if($profile_macparts[$_] eq "*");
            if(lc($profile_macparts[$_]) ne lc($macparts[$_])) {
                $match = 0;
                last;
            }
        }
        if($match) {
            $profile_path = $profile->[1];
            last;
        }
    }
    return $profile_path;
}

sub handle_request {
    my $conn = shift;

    my $request = $conn->get_request;
    my ($path, $args) = parse_request_url($request->url);
    my $debugargs = "";
    foreach(keys %{$args}) {
        $debugargs .= ($debugargs ? ", " : "") . $_ . "->" . $args->{$_};
    }
    debug($conn->peerhost() . ":" . $conn->peerport() . " " . $path . " " . $debugargs);

    if($request->method ne "GET") {
        $conn->send_error(RC_FORBIDDEN);
        return;
    }

    if($path eq "/get_profile_path") {
        my $profile_path = get_profile_path($args->{mac});
        if($profile_path =~ /^\//) {
            $profile_path = "kicktoo:///get_profile?mac=" . $args->{mac};
        }
        send_response($conn, $profile_path);
    } elsif($path eq "/get_profile") {
        $conn->send_file_response(get_profile_path($args->{mac}));
    } else {
        # we don't need to respond it's just a server log update
        # therefore sending http 404
        $conn->send_basic_header(404);
        $conn->send_crlf;
        print $conn "Unknown command";
    }
}

sub main {
    my $daemon = create_daemon();

    if(!defined $daemon) {
        print "!!! Could not create daemon\n";
        exit 1;
    }
    debug("HTTP Daemon started on port $conf{port}...\n");

    # wait for connection
    while(my $conn = $daemon->accept) {
        handle_request($conn);
        $conn->close;
    }
}

main();
